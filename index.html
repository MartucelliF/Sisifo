<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/styles.css">
    <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
    <title>TP POO - Recreación Web</title>
</head>

<body>
    <hr width="1100px">
    <div class="caratula">
        <h1>
            Escuela Técnica Nº 35 D.E 18
            <br>
            <img src="img/logo35.png" alt="logo35" width="200px" height="200px" srcset="">
            <br>
            Ing. Eduardo Latzina
        </h1>
        <div class="contDatos">
            <h2>TP - Paradigma Orientado a Objetos</h2>
            <br>
            <br>
            <div class="datos">
                <b>DOCENTE:</b> Villanueva Silvina
                <br>
                <b>MATERIA:</b> Programación sobre Redes
                <br>
                <b>ESTUDIANTE:</b> Martucelli Franco Sebastián
                <br>
                <b>CURSO:</b> 6to 3ra
                <br>
                <b>TURNO CURSADA:</b> NOCHE
                <br>
                <b>FECHA DE ENTREGA:</b> 04/04/2024
            </div>
        </div>
    </div>
    <br>
    <hr width="1100px">
    <div class="contAclaracion">
        <div class="aclaracion">
            El (<b>N</b>) adjunto a cada título corresponde al número de la pregunta que se está respondiendo en cada
            apartado
        </div>
    </div>
    <hr width="1100px">
    <br>
    <div class="respuestas">
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(1) Paradigma Orientado a Objetos, (4) Atributos y (3) Clase:</b></u>
                <br>&nbsp;&nbsp;En primer lugar, un paradigma es una manera de pensar, de implementar una serie de
                normas o estándares, e interpretar escenarios.
                Con esto, un <b><i>Paradigma Orientado a Objetos</i></b> se puede entender como toda aquella abstracción
                del mundo real, es decir, la representación (de manera lógica) de aquellos objetos que
                percibimos.<br>&nbsp;La manera principal en la cual este paradigma se lleva a cabo es mediante las
                “<b>clases</b>”, que resuelve los diferentes datos de los objetos en forma de información conjunta.<img
                    src="img/1.png" alt="claseAlumno" width="100px" height="100px" srcset=""><br>
                &nbsp;&nbsp;De forma sencilla, es como si cada clase fuera una plantilla o molde. Por ejemplo, los
                moldes para formar figuras con plastilina.
                Por lo tanto, cuando queramos traer un objeto de la vida real, vamos a pensar qué <b>atributos</b> tiene
                para poder crear un molde de este <b>objeto</b>.
                <br>&nbsp;&nbsp;Estos <b>atributos</b> no son más que aquellas <b>características elementales</b> de
                cada una de estos objetos, tal como si se tratara de campos, similar a Bases de Datos, teniendo a los
                objetos como <b>entidades</b>.
            </div>
        </div>
        <br>
        <hr width="1100px">
        <br>
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(2) Objeto:</b></u>
                <br>&nbsp;&nbsp;Es una instancia de una clase. Representación de un objeto de la vida real.
                Partiendo del ejemplo que planteé anteriormente, el <b>Alumno</b> sería el molde (<b>clase</b>) a seguir
                para las diferentes plastilinas (<b>objetos</b>), si bien pueden tener diferentes colores (<b>datos,
                    valores</b>), todas tienen la misma forma (<b>campos</b>) <i class='bx bx-right-arrow-alt'></i>
                todas nacen del mismo molde (<b>clase</b>).
                <br><br>
                <div class="contImg">
                    <img src="img/2.png" alt="objetosAlumno" width="350px" height="300px">
                </div>
                <br>
                &nbsp;&nbsp;Una característica importante de estos objetos es la existencia de “<b>métodos</b>”, que se
                resume en aquellas acciones que cada uno puede realizar.
                <br>&nbsp; A continuación los detallo bien…
            </div>
        </div>

        <hr width="1100px">
        <br>
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(5) Métodos:</b></u>
                <br>&nbsp;&nbsp;Así como los atributos nos dicen cuáles son las características que tiene un objeto, los
                <b>métodos</b> son las <b>acciones</b> que ese objeto puede realizar con esas características.
                Los métodos se pueden entender como <b>funciones</b> dentro de las clases….
                <br><br>
                <b>1. <span style="color: red;">public </span><span style="color: rgb(0, 255, 0);">void </span><span
                        style="color: blue;">mostrarNombre()</span>{</b><br>
                }<br>
                <span class="textoCentrado">
                    <span style="color: red;">modificador de acceso</span><br>
                    <span style="color: rgb(0, 255, 0);">tipo de dato que va a devolver (ninguno en este caso, sólo
                        realiza una operación)</span><br>
                    <span style="color: blue;">entre paréntesis se ponen qué parámetros va a recibir para realizar la
                        operación específica, en este caso ninguno</span>
                </span>
                <br><br><br><br>
                <b>2. public void saberAprobado(int calificacion){</b><br>
                <span class="textoCentrado">
                    <b>if</b>(calificacion >= 6)<b>{</b>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Aprobé compa!");
                    <br>
                    <b>}
                        else{</b>
                    <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("F...mala suerte");
                    <br>
                    <b>}</b>
                    <br>
                    <span style="color: blue;">en este caso sí recibe un parámetro (una variable de tipo int)</span>
                </span>
                <br><br><br><br><br><br>
                <b>}</b>
                <br><br>
                Todos estos métodos están dentro de la clase Alumno, por lo tanto son métodos (funciones) que esa clase
                puede realizar.
            </div>
        </div>
        <hr width="1100px">
        <br>
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(7) Herencia:</b></u>
                <br>&nbsp;&nbsp;Partiendo de la base de que la herencia como la conocemos, consiste en la transmisión
                genética de características similares y unívocas de un padre/madre a un hijo/a, pasado a un ámbito
                informático podemos decir que hay clases que pueden compartir entre sí los atributos que ya definí
                anteriormente.
                <br><br>
                <span class="textoCentrado">
                    ➢si una clase madre tiene <b><i>nombre</i></b> y <b><i>apellido</i></b>, su clase hija va a heredar
                    el campo <b><i>nombre</i></b> y <b><i>apellido</i></b> (mas no los datos; sólo el campo)
                    <br><br>
                    ➢estas subclases o clases hijas pueden tener sus propios métodos o campos, pero sí o sí van a
                    heredar las mismas características que su clase madre
                </span>
                <p>
                    <b>REPRESENTACIÓN CON UNA ESTRUCTURA GRÁFICA:</b>
                </p>
                <span class="contImg">
                    <img src="img/3.png" alt="objetosAlumno" width="500px" height="600px">
                </span>
                <i>Los datos los tomé de una obra ficticia llamada “Tokyo Ghoul” que divide a las personas entre humanos
                    y ghouls (demonios), siendo los investigadores quiénes combaten contra estos seres.</i>
                <br><br>
                <span class="textoCentrado">
                    <b>➢public class</b> Investigador <b><span style="color: rgb(255, 0, 255);">extends</span>
                        Persona(){<br>
                        }</b><br>
                </span>
                <br><br><br>
                <span class="textoCentrado">
                    <b>➢public class</b> Ghoul <b><span style="color: rgb(255, 0, 255);">extends</span> Persona(){<br>
                        }</b><br>
                </span>
                <br><br><br><br>
                Esto declara que ambas clases heredan (<b>extienden</b>) los campos de la <b>clase madre Persona</b>, de
                esta forma, una vez que se definen los campos propios de cada clase, se pueden combinar con los de la
                clase madre (Persona) como si de la propia clase se tratase.
            </div>
        </div>
        <hr width="1100px">
        <br>
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(9) Polimorfismo:</b></u>
                <br><br>
                <b>POLIMORFISMO</b> [<b>POLI</b> → MUCHAS | <b>MORFISMO</b> → FORMAS]
                <br><br>
                Permite relacionar <b>diferentes tipos de datos</b>, en diferentes formas de clases Hijas, mientras
                pertenezcan a la misma <b>clase Madre</b>.
                <br><br>
                Esto se puede ejemplificar con funciones, donde todas las hijas pueden utilizar el mismo método que la
                madre. Pero simplifiquemos en un vector.
                <br><br>
                Sabemos que en un vector de tipo String no se pueden introducir datos de tipo Int, ya que habría una
                incompatibilidad. De la misma forma sucede al revés.
                <br><br>
                <div class="contAclaracion">
                    <div class="aclaracion">
                        Regla de ORO en Java: <b><i>NO podemos mezclar tipos de datos</i></b>
                    </div>
                </div>
                <br>
                Entonces, una forma de permitir el uso de múltiples tipos de datos va a ser mediante la Herencia. Ya que
                es como si, para poder permitir esta característica, la clase Madre fuera una sala VIP a la que sólo las
                clases Hijas tienen acceso a ella. Por ende, sólo entre ellas podrán mezclarse los tipos de datos. Bajo
                la supervisión de la Madre, claro.
                <br><br>
                Con esta propiedad vamos a poder definir varios objetos dentro de las clases Hijas que a su vez van a
                estar asignados a diferentes objetos de la clase Madre.
                <br><br>
                <div class="contImg">
                    <img src="img/4.png" alt="objetosAlumno" width="600px" height="225px">
                </div>
                <br><br><br>
                <b>
                    REPRESENTACIÓN CON UNA ESTRUCTURA GRÁFICA:
                    <br>
                    <span class="textoCentrado">
                        <i>(partiendo del ejemplo anterior)</i>
                    </span>
                </b>
                <br><br>
                <div class="contImg">
                    <img src="img/5.png" alt="objetosAlumno" width="900px" height="525px">
                </div>
                <br>
                Como se puede ver en el ejemplo, se definen <b>dos vectores de tipo clase Hija</b> que tienen dentro
                objetos con cada uno valores diferentes, luego, en el <b>vector de la clase Madre</b> creo dos objetos
                que contienen a estas clases Hijas junto con todos sus <b>respectivos objetos</b>.
                <br><br>
                Ahora, con los diferentes objetos definidos para los vectores de las clases Hija, se puede definir el
                vector de la clase Madre pasándole como Objetos estos vectores.
                <br><br>
                A continuación, una demostración sintáctica repasando un poco sobre encima la Herencia y representado
                detalladamente el ejemplo del Polimorfismo…
                <br><br>
                <div class="contImg">
                    <img src="img/6.png" alt="objetosAlumno" width="650px" height="600px">
                </div>
                <div class="contDatos">
                    <div class="datos">
                        <b><i class='bx bxs-error'></i> IMPORTANTÍSIMA ACLARACIÓN <i class='bx bxs-error'></i></b>
                        <br><br>
                        <i>Las siguientes líneas deben ir dentro de sus respectivos <b>ciclos for</b><i
                                class='bx bx-right-arrow-alt'></i></i>
                        <br>
                        <div class="contDatos">
                            <ul>
                                <div class="datos">
                                    <li><span><b>Ghoul</b> ghoul = (<b>Ghoul</b>) vectorGhoul[j]</span></li>
                                    <li><b>Investigador</b> investigador = (<b>Investigador</b>)vectorInvestigador[j]
                                    </li>
                                </div>
                            </ul>
                        </div>
                        <br><br><br>
                        <i>
                            Yo las coloqué fuera adrede con el único objetivo de dar un<br>enfoque total a la asignación
                            de datos y contemplarla con la<br>información completa del Poliformismo. Pero si las líneas
                            están<br>fuera de los ciclos “hijos”, entonces, sólo se mostrarán los datos<br>de la primera
                            persona ingresada para cada caso.
                        </i>
                        <br><br>
                        <b><i class='bx bxs-error'></i> IMPORTANTÍSIMA ACLARACIÓN <i class='bx bxs-error'></i></b>
                    </div>
                </div>
                <br><br>
                <b style="color: red;">1. DEFINICIÓN DEL VECTOR MADRE.</b>
                <br>
                Se declara el límite de valores que puede tomar el vector. Dicho de otra forma, se define con cuántas
                clases hijas se va a tratar. En este caso son dos: clase Ghoul y clase Investigador
                <br><br>
                <b style="color: red;">2. ASIGNACIÓN DE CADA CLASE HIJA AL VECTOR MADRE.</b>
                <br>
                En la primera asignación, le estamos diciendo que, todos los valores que pertenezcan a la clase hija
                <b>Ghoul</b>, van a ser asignados a esa posición de memoria <b>vectorPersona[0]</b>.
                <br>
                Lo mismo ocurre en la segunda asignación; le estamos diciendo que, todos los valores que pertenezcan a
                la clase hija <b>Investigador</b>, van a ser asignados a esa posición de memoria
                <b>vectorPersona[1]</b>.
                <br>
                Esta es la parte fundamental del polimorfismo, ya que, en este ejemplo, es donde se <i>firma</i>
                explícitamente.
                <br><br>
                <b style="color: red;">3. RECORRE LOS VALORES DEL VECTOR MADRE.</b>
                <br>
                Si está todo correctamente asignado, entonces en este punto, el primer valor de <b>i</b> debe ser
                <b>0</b>, asignado a la clase hija Ghoul. Lo que hace que el <b>ciclo for</b> recorra la primera
                posición de memoria hasta que esta tome como último valor el <b>1</b>, asignado a la clase hija
                Investigador.
                <br>
                Al haber definido como límite de clases hijas a tratar <b>[2]</b>, se pondrá como límite <b>&lt;2</b>
                para que no supere dicho valor.
                <br><br>
                <b style="color: red;">4. RECORRE LOS VALORES DEL VECTOR MADRE.
                    <br>
                    #Primera vuelta</b>
                <br>
                <span class="textoCentrado">
                    Para lo cual nosotros, algorítmicamente, le preguntamos “<b><i>¿Corresponde esta posición de memoria
                            a una instancia de la clase hija Ghoul?</i></b>”.
                    <br>
                    Al haber definido previamente <i class='bx bx-right-arrow-alt'></i>'<b><i>vectorPersona[<span
                                style="color: rgb(153, 0, 255);">0</span>] = <span
                                style="color: rgb(153, 0, 255);">new</span> <span style="color: red;">Ghoul</i></b>', la
                    respuesta será afirmativa siendo la primera vez que recorre el vector.
                    <br>
                    Pero el código a ejecutar sigue, y la siguiente cuestión es “<b><i>¿Corresponde esta posición de
                            memoria a una instancia de la clase hija Investigador?</i></b>”.
                    <br>
                    Si se recuerda bien, previamente definí '<b><i>vectorPersona[<span
                                style="color: rgb(153, 0, 255);">1</span>] = <span
                                style="color: rgb(153, 0, 255);">new</span> <span
                                style="color: red;">Investigador</i></b>', por lo que la respuesta será negativa, dado
                    que el valor de <b>i = 0</b>.
                </span>
                <br>
                <b style="color: red;">#Segunda vuelta</b>
                <br>
                <span class="textoCentrado">
                    Volverá a preguntar si corresponde o no a una instancia de Ghoul. Siendo en este caso negativa,
                    puesto que el valor de i ahora es 1.
                    <br>
                    Entonces, al llegar al último tramo del código, tocará comprobar si esta posición de memoria que se
                    está recorriendo es o no perteneciente a una clase hija Investigador. Para lo que en este caso, la
                    respuesta será afirmativa.
                </span>
                <br><br>
                <b style="color: red;">5. MUESTRA LOS VALORES DE CADA CLASE HIJA.</b>
                <br>
                Declarando una variable <b>j</b>, recorremos el vector de cada clase hija.
                Asignamos cada valor que va tomando esa variable, a cada posición de memoria que recorre de cada vector
                de cada una de las clases hijas.
                <b>NG</b> y <b>NI</b> son dos variables globales que definen, respectivamente, el límite de personas
                para cada vector <b>Ghoul e Investigador</b>.
            </div>
        </div>
        <hr width="1100px">
        <br>
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(8) Encapsulamiento:</b></u>
                <br>&nbsp;&nbsp;Funciona como un delimitador de acceso para las clases y sus métodos.<br>
                Con esto se puede definir qué tan “accesible” se quiere que sean.<br>
                <img src="img/7.png" alt="claseAlumno" width="500px" height="150px" srcset="">
                <br>
                En <span style="color: red; background-color: black;"><b>PUBLIC</b></span>, cualquier entidad, dentro y fuera de la clase donde definí el tipo de acceso, va a poder acceder.
                <br><br>
                En <span style="color: yellow; background-color: black;"><b>PRIVATE</b></span>, cualquier entidad, sólo dentro de la clase donde definí el tipo de acceso (no fuera), va a poder acceder.
                <br><br><br><br>
                Ahora, si es <span style="color: rgb(5, 173, 237); background-color: black;"><b>PROTECTED</b></span>, va a incluir la característica del <span style="color: yellow; background-color: black;"><b>PRIVATE</b></span>, siendo accesible para aquellos elementos que se encuentren dentro de la propia clase y no fuera. Pero con el plus de que, si tiene clases Hijas, estas también van a poder acceder, por más que estén fuera. 
                <br><br>
                <br><b>Ejemplo sencillo utilizando la  interfaz de NetBeans:</b>
                <br><br>
                <div class="contImg">
                    <img src="img/8.png" alt="objetosAlumno" width="650px" height="500px">
                </div>
                <br>
                Partiendo del mismo ejemplo de antes de la clase madre Persona con sus clases hijas Ghoul e Investigador, se puede ver como Persona está en <span style="color: red; background-color: black;"><b>PUBLIC</b></span>. 
                Pero, si lo cambiamos a <span style="color: yellow; background-color: black;"><b>PRIVATE</b></span> ocurre lo siguiente…
                <br><br>
                <div class="contImg">
                    <img src="img/9.png" alt="objetosAlumno" width="500px" height="150px">
                </div>
                <br>
                Sus clases Hijas ya no van a tener acceso a la clase Madre ni a sus métodos por encontrarse estas fuera. De hecho, ese subrayado amarillo en <span style="color: rgb(106, 168, 79);"><b>Persona</b></span> avisa que sus métodos nunca son utilizados ya que no hay nadie, con acceso, que pueda utilizarlos.
                <br>
                Por ello, en este caso particular, donde lo más importante entre estas clases es la vinculación entre ellas, lo mejor es delimitar esta clase Persona con un <span style="color: rgb(5, 173, 237); background-color: black;"><b>PROTECTED</b></span>.
                <br><br>
                <div class="contImg">
                    <img src="img/10.png" alt="objetosAlumno" width="500px" height="150px">
                </div>
                <br>
            </div>
        </div>
        <hr width="1100px">
        <br>
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(6) Abstracción:</b></u>
                <br>
                Para entender bien este concepto, es necesario comprender que cuando se refiere a algo abstracto, hablando del mundo real, se refiere a algo que no está propiamente definido, que puede tomar muchas formas o interpretaciones.
                <br><br>
                De esta forma, una clase Abstracta va a ser una plantilla que va a servir como molde para otras clases. 
                <br><br>
                Como si tuviéramos una hoja en blanco con una carátula y varios espacios vacíos donde iría una firma, espacios para una foto, etc. Y que luego, se hagan varias <b>impresiones</b> de ese mismo <b>molde</b> en blanco y rellene los datos y todo lo demás únicamente en las impresiones, pero no en el molde, ya que no tendría sentido, porque necesito una <b>base de la que trabajar</b>. 
                <br><br>
                Claro que esta primera hoja con espacios en blancos sería la Clase Madre y el resto de copias a las que sí voy a rellenar serían las clases Hijas.
                <br><br>
                <img src="img/11.png" alt="claseAlumno" width="325px" height="325px" srcset="">
                <br><br>
                En este ejemplo, nuestra clase Abstracta sería <b>Figura</b>, habiendo varias interpretaciones para esta: figura circular, figura cuadrada, figura rectangular…
                <br><br>
                La clave está en definir en Figura aquellas características en común que tengan todas las propias figuras.
                <br><br>
                Cada una va a tener atributos y métodos en común, como <b>calcularArea</b>, todas las figuras van a tener un Área, pero cada una la va calcular de forma diferente. 
                <br><br>
                Por esto último se dice que la Abstracción define el “<b>ES/SER</b>” de una clase, mas no su “<b>CÓMO</b>”.
            </div>
        </div>
        <hr width="1100px">
        <br>
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(10) Asociación:</b></u>
                <br>
                Análogamente con el ejemplo de una Base De Datos, se puede considerar como la “tabla débil” entre dos tablas fuertes que sirve para asociar los datos de la misma que, independientemente pueden no tener mucho sentido, pero en conjunto pueden tener un significado. 
                <br><br>
                <div class="contImg">
                    <img src="img/12.png" alt="objetosAlumno" width="500px" height="150px">
                </div>
                <br><br>
                Esto sería similar a crear directamente una clase con ambos datos y vincularlos en la propia clase a partir de los objetos.
                <br><br>
            </div>
        </div>
        <hr width="1100px">
        <div class="contRespuesta">
            <div class="respuesta">
                <u><b>(11) Agregación:</b></u>
                <br>
                Sencillamente, una clase <b>USA</b> un objeto de otra. Con el <b><i>USO</i></b> me refiero a poder, por ejemplo, declarar un vector dentro de una clase sin objetos y que las posiciones de memoria de este vector estén almacenadas con información de otra clase.
                <br>
                Para este ejemplo es fundamental definir cuántas clases van a ser agregadas dentro.
                <br>
                <img src="img/13.png" alt="objetosAlumno" width="500px" height="150px">
                Así es, esto ya lo había mencionado anteriormente con el ejemplo del Polimorfismo.
                <br>
                En el ejemplo, la clase Persona, estoy creando un <b>vectorPersona</b> que agrega objetos de la clase <b>Persona</b>. Sin embargo, los objetos que almacenaremos serán de las clases Ghoul e Investigador. En este ejemplo, se denota que ambas clases no necesitan depender de esta relación para sobrevivir, así como sí lo necesita una de las otras características de la POO que es la <b>Composición</b>.
                <br><br>
            </div>
        </div>
        <hr width="1100px">
    </div>
</body>

</html>